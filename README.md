# RANDOMART - Не совсем уж и рандомный ...

## Abstract

`randomart`, что означает рандомное искусство, является графическим представлением отпечатка  публичного ключа SSH (fingerprint). Главная идея этого графического объекта заключается в том, что человеку легче запоминать картинки или набор картинок, чем строку, состоящую из сложных комбинаций различных символов. Такими строками могут являться пароли, хеш-суммы, токены и тому подобное.

По этой причине в новых версиях криптографической библиотеки OpenSSH был добавлен метод генерации картинок на основе отпечатка публичного ключа. В этой статье речь пойдёт дальше о том, как создаётся randomart.

**Keywords**: randomart, SSH, OpenSSH, визуализация, аутентификация, алгоритм генерации, публичный ключ, приватный ключ, MD5, хеш-функции, кодировки, UTF-8.

## Introduction

Почти любое взаимодействие по сети сегодня не обходится без протоколов SSL/TLS (Secure Socket Layer) и SSH (Secure Shell). Первый из них подтверждает подлинность веб-сайтов и устанавливает безопасное соединение. Если вы имеете дело с защищённым веб-сайтом, то вы можете проверить цепочку из сертификатов и ключей, полученных вашим браузером. Для примера приведём один из сертификатов, полученный при отправке запроса в Google:
```
*.google.com
Identity: *.google.com
Verified by: WR2
Expires: 24.02.2025

Subject Name
CN (Common Name):	*.google.com
Issuer Name
C (Country):	US
O (Organization):	Google Trust Services
CN (Common Name):	WR2
Issued Certificate
Version:	3
Serial Number:	00 FC 12 5B BD 5B 36 EA 6B 12 3B 0A 55 49 88 4C 9F
Not Valid Before:	2024-12-02
Not Valid After:	2025-02-24
Certificate Fingerprints
SHA1:	36 7C F6 D0 DA DB 45 E1 80 A6 76 D2 C1 A5 38 1A 0B 8D 99 4E
MD5:	56 7B 47 6C 3C D2 77 3B 88 8A AE 61 AF 9C 69 70
Public Key Info
Key Algorithm:	Elliptic Curve
Key Parameters:	06 08 2A 86 48 CE 3D 03 01 07
Key Size:	256
Key SHA1 Fingerprint:	15 51 AD 0A B5 6D 75 80 0C 22 B3 E7 28 2E E0 D6 51 94 9F 8D
Public Key:	04 EF 5B 13 8A 5A D7 D6 5D D6 7C FF 1F D2 B1 0C D4 4D 37 2D BC C8 88 8F DD 52 71 44 FB 98 59 B4 88 E0 C9 26 BE CD 10 5F BD C8 C2 CB 18 CA 55 8F 1F BD EF 10 CB 2D 1B FC BC CD FC 5D 2D AF C1 65 82
```

В примере выше мы можем выделить поле `Public Key`, которое содержит публичный ключ в шестнадцатеричном виде.

Второй протокол (SSH) позволяет подключиться к удалённому серверу, отправлять и принимать файлы, создавать зашифрованные туннели и многое другое. Этот протокол может использовать пароли для аутентификации, но чаще всего на серверах блокирует эту опцию, так как сервер может быть подвержен атаке bruteforce с перебором паролей. Вместо пароля используется пара ключей, которые дополняют друг друга — публичный и приватный ключ.

Главная идея заключается в следующем: если вы зашифровали сообщение публичным ключом, то расшифровывать это сообщение может только тот, у кого есть соответствующий приватный ключ, и наоборот. Публичным ключом мы можем поделиться со всеми, но приватный должен быть только у одного сервера.

Таким образом, в обычной практике, если у удалённого сервера будет публичный ключ от вашего компьютера, то вы сможете, используя свой приватный ключ, подключиться к нему:
1. Вы отправляете запрос, чтобы подключиться к серверу.
2. Удалённый сервер находит ваш ключ в списке `/home/<user>/.ssh/authorized_keys` и присылает вам зашифрованное сообщение вашим публичным ключом.
3. Вы расшифровываете его приватным и зашифровываете обратно, но теперь уже приватным ключом, затем отправляете обратно.
4. Удалённый сервер получает его и расшифровывает вашим публичным ключом.

Далее речь подходит к главной теме — randomart.

## RANDOMART

Чтобы мы могли подключиться к удалённому серверу, как мы говорили ранее, необходимо загрузить свой публичный ключ в него. Это делается легко: находясь на удалённом сервере, вы открываете файл  `/home/<user>/.ssh/authorized_keys` и добавляете в него содержимое вашего ключа вручную. То же самое за вас сделает утилита `ssh-copy-id`, если у вас ещё есть доступ по паролю (обычно вначале бывает доступен вход по паролю; только тогда, когда вы загрузите свой ключ, можно отключить вход по паролю в конфигурации SSH).

Но для начала нужен сам публичный ключ. Если вы возьмёте любой публичный ключ и загрузите его на удалённый сервер, то не сможете расшифровать полученное сообщение от сервера, так как приватной части у вас не будет хватать для расшифровки.

Итак, создаём пару ключей утилитой `ssh-keygen`:
```
user@hostname:/$ ssh-keygen
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in some
Your public key has been saved in some.pub
The key fingerprint is:
SHA256:msCih9N21AejTO+YGF5IK6zX3ukCHCn8oUdGR76NLng user@hostname
The key's randomart image is:
+---[RSA 3072]----+
|    ..           |
|   ...           |
|. o.o.o          |
|oooX ++o         |
|.+X.Ooo.S        |
|.B+X.= +         |
|=.OE=.+          |
| =.oo. .         |
|    .o+          |
+----[SHA256]-----+
```
В выводе этой команды вы увидите отпечаток `SHA256:msCi...6NLng user@hostname`
и рисунок на основе этого отпечатка, который называется randomart.

Отпечаток ключа (fingerprint) создаётся криптографическими хеш-функциями на основе публичного ключа, именно этот отпечаток использует удалённый сервер, чтобы найти тот публичный ключ, который вы ему оставили в файле `/home/<user>/.ssh/authorized_keys`.

Если с отпечатком всё понятно, то зачем рисунок randomart? Дело в том, что, когда ваш компьютер подключается к удалённому серверу и видит новый отпечаток публичного ключа, это означает, что он либо видит его в первый раз, либо его подменили, и у вас идёт сценарий Man-In-The-Middle (MITM). Из-за серьёзности этой кибератаки ваш компьютер предоставит вам отпечаток публичного ключа удалённого сервера и заблокирует соединение, пока вы не проверите сами и не дадите согласие:
```
uset@hostname:/$ ssh computersciencebrand.ru
The authenticity of host ’computersciencebrand.ru (31.31.198.43)’ can’t be eastablished. RSA key fingerprint is fc:94:b0:c1:e5:b0:98:7c:58:43:99:76:97:ee:9f:b7 Are you sure you want to continue connecting (yes/no)?
```
В каком из двух сценариев вы оказались, вы не поймёте, если подключаетесь с нового устройства или удалили записи из файла `known_hosts`. Поэтому в идеале вы сравниваете полученный отпечаток с тем, что ожидали от сервера (тот, что сгенерировали на удалённом сервере утилитой ssh-keygen).

Дав согласие, вы добавите этот отпечаток этого сервера в свою папку `~/.ssh/known_hosts`, и в следующий раз соединение не будет заблокировано, пока отпечаток не поменяется снова. Но, как вы заметили, запоминать такой отпечаток нелегко. Даже если записать его и потом сравнивать посимвольно, тоже будет неудобно.

Тут нам как раз может облегчить задачу randomart, так как запоминать графический отпечаток проще, чем шестнадцатеричный. Начиная с версии OpenSSH 5.1 вы найдёте опцию для генерации randomart, которая показывает вам при каждом подключении соответствующий рисунок. Даже если вы подключаетесь теперь с нового устройства, вам достаточно взглянуть на рисунок, чтобы понять, не поменялось ли что-нибудь, тот ли сервер.

Сам randomart очень чувствителен к изменениям, поэтому, если кто-то что-то поменял, рисунок будет совсем другим, что придаёт надёжность этому методу.

### SSH CONFIGURATION (VisualHostKey)

Чтобы каждый раз SSH показывал `randomart` при подключении к удаленному серверу, найдите файл конфигурации `/etc/ssh/ssh_config` и включите опцию `VisualHostKey`:

```
...
#   PermitLocalCommand no
#   VisualHostKey no
#   ProxyCommand ssh 
...
```

```
...
#   PermitLocalCommand no
    VisualHostKey yes
#   ProxyCommand ssh -q -W %h:%p gateway.example.com
...
```

## GENERATING RANDOMART

### FINGERPRINT GENERATION

Рассмотрим алгоритм, который создаёт рисунок randomart. У любого публичного ключа есть свой отпечаток — fingerprint. OpenSSH использует криптографическую хеш-функцию MD5 (Message Digest 5), чтобы сгенерировать 128-битный двоичный код (16 байтов). Для удобства каждый байт делят на две части (4 бита) и выписывают их содержание в шестнадцатеричном виде, что в сумме даёт нам 32 шестнадцатеричных числа.
```
8 [bit] = 8 [byte]
128 [bit] = 16 [byte]
2 * 16 [byte] = 32 [1/2 byte]
```
Перевод из двоичного кода, который нужно разбить по 4 битам, будет выглядеть следующим образом:
```
1101 [2] => d [16]
0110 [2] => 6 [16]
1010 [2] => a [16]
0110 [2] => 6 [16]
...
d6:a6:...
```
Получаем в итоге такой хеш из 32 чисел, где каждый байт разделён двоеточием:
```
user$hostname:/$ ssh-keygen -l -E md5 -f key.pub 
3072 MD5:d6:a6:f5:2e:63:39:59:95:03:fd:74:41:b3:28:47:47 user@hostname (RSA)
```
Каждые 4 бит будут направлять алгоритм, чтобы он выставил в нужное место подобранный ASCII символ и собрал конечную картину.

### MAPPING

Чтобы, глядя на алгоритм, мы могли понять его суть, нужно представить отпечаток в двоичном виде, разбитый по 2 битам. Например:

```
d6 => 11010110 => 11 01 01 10
a6 => 10100110 => 10 10 01 10
```
Затем соотнести каждую такую двубитную последовательность с опредленным направлением:
```
00 ↖️
01 ↗️
10 ↙️
11 ↘️
```
От любой точки (кроме крайних) можно двинуться в сторону любого квадранта:
```
00|01
--+--
10|11
```
Так как байт состоит из 8 бит, то каждый определяет четыре направления движения:
```
D6 = 11 01 01 10 = ↘️ ↗️ ↗️ ↙️
+---+---+---+---+---+---+
|   |   |   |   |   |   |
+---+---+---+---+---+---+
|   |   |   |   |   | 1 |
+---+---+---+---+--↓↗---+
|   |   |   |   | 2 |   |
+---+---+---S↓--↗---+---+
|   |   |   | 1 |   |   |
+---+---+---+---+---+---+
|   |   |   |   |   |   |
+---+---+---+---+---+---+
|   |   |   |   |   |   |
+---+---+---+---+---+---+
```
Таким образом, алгоритм, сканируя байт за байтом, строит свой маршрут. Если представить движение алгоритима в виде тепловой карты, мы получим следующую аниммацию:

![randomart](https://raw.githubusercontent.com/computer-science-brand/CRYPTOGRAPHIC/refs/heads/randomart/resources/randomart_heatmap.gif)

### VALUES

В примере выше мы увидели, что алгоритм может свернуть в один момент и вернуться на исходное положение. Каждый раз, когда алгоритм наступает на какую-то клетку, мы инкрементируем число, содержащееся в этой клетке (все клетки по умолчанию равны нулю). По окончании этого обхода клетки на карте будут отмечены числами:

```
4,2,3,5,0,3,0,2,0,5,6,2,3,2,5,2,1
0,4,2,3,6,1,2,0,3,1,2,4,0,1,0,2,1
0,0,1,3,1,3,0,0,0,1,3,0,0,1,2,1,0
0,0,0,0,2,0,0,0,0,3,0,1,1,1,1,0,0
0,0,0,0,0,2,0,0,0,0,1,0,0,1,0,0,0
0,0,0,0,0,0,2,0,0,0,0,0,2,0,1,0,0
0,0,0,0,0,0,0,1,0,0,0,3,0,1,0,1,0
0,0,0,0,0,0,0,0,1,0,2,0,0,0,1,0,0
0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
```
, где каждое число подсказывает, сколько раз по ней итерировал алгоритм, составляя свой маршрут.

Составляем свою кодировку, где каждому числу ставим в соответствии какой-то символ:

```csv
value,char
0," "
1,"."
2,"o"
3,"+"
4,"="
5,"*"
6,"B"
7,"0"
8,"X"
9,"@"
10,"&"
11,"%"
12,"#"
13,"/"
14,"^"
15,"S"
16,"E"
```
Затем выставляем каждой клетке соответствующий символ:
```
+--[ED25519 256]--+
|=o+*L+ o *Bo+o*o.|
| =o+B.o +.o= . o.|
|  .+.+   .+  .o. |
|    o    + ....  |
|     o  S .  .   |
|      o     o .  |
|       .   + . . |
|        . o   .  |
|         .       |
+----[SHA256]-----+
```

И да, мы можем составить любую кодировку: на китайском, японском или на языке эмодзи — всё в рамках UTF-8.

![print](https://raw.githubusercontent.com/computer-science-brand/CRYPTOGRAPHIC/refs/heads/randomart/resources/JP.png)

### MAP FORMAT

Размер полученной картинки и сам образ зависят от реализованного алгоритма. В реализации библиотеки OpenSSH ширина картинки составляет 17 символов, а высота — 9 символов, что даёт 9 × 17 = 153 возможных позиций. Начало маршрута расположено посередине картинки:

```
            1111111
  01234567890123456
 +-----------------+x (column)
0|                 |
1|                 |
2|                 |
3|                 |
4|        S        |
5|                 |
6|                 |
7|                 |
8|                 |
9|                 |
 +-----------------+
 y
(row)
```
С точки зрения программирования, удобнее представить всю картинку как один массив, как это делают с алгоритмами обработки изображения. В таком случае каждая новая строка начнётся через 17 символов. Найти позицию по координатам X и Y можно по следующей формуле:
```
pos(x, y) = x + 17y
```

## CONCLUSION

Данная тема достойна внимания, так как мы не учитываем сильные и слабые стороны человека, создавая системы, которые требуют запоминания сложных комбинаций. У человека довольно хорошая зрительная память, и мы можем этим воспользоваться. И randomart — это хороший пример того, как мы можем реализовать прокеты с учетом зрительной памяти.

## Resources
- [Hash Visualization: a New Technique to improve Real-World Security](https://users.ece.cmu.edu/~adrian/projects/validation/validation.pdf)
- [The drunken bishop: An analysis of the OpenSSH fingerprint visualization algorithm](http://www.dirk-loss.de/sshvis/drunken_bishop.pdf)
- [Making art with SSH key randomart](https://blog.benjojo.co.uk/post/ssh-randomart-how-does-it-work-art)
- [Source code in C](src/randomart.c)
